# UIControl Desktop Shell Guide

## Project Positioning
- Cross-platform desktop shell built on Tauri 2 + React 19, forming rapid prototyping environment through combination of web frontend and Rust backend.
- Goal is to provide extensible foundation for UI automation or console tools, default example demonstrates how to use `invoke` to trigger Rust commands and return data.
- Introduce `@tauri-apps/plugin-opener` to unify external link behavior, convenient for opening documentation or system resources in desktop environment.

## User Scenarios
- Desktop debugging: Use `pnpm tauri dev` to start Tauri DevServer, launching both Rust backend and React frontend simultaneously, suitable for end-to-end joint debugging.
- Frontend iteration: Use `pnpm dev` to run Vite alone, quickly verify UI components or state logic before returning to Tauri.
- Packaging and release: Generate Windows/macOS/Linux installation packages through `pnpm tauri build`, build process automatically calls `pnpm build` to produce frontend static resources.
- API verification: Use `invoke("greet", { name })` example to verify Rust Command pathway, providing reference for subsequent custom command extensions.

## Technology Stack
- Frontend: React 19 + TypeScript 5.9 + Vite 7, state management currently relies on React Hooks.
- Desktop shell: Tauri 2, default window size and CSP configured in `src-tauri/tauri.conf.json`.
- Backend: Rust 2021 Edition, commands registered in `src-tauri/src/lib.rs`, `tauri-plugin-opener` as built-in plugin.
- Package management: `pnpm@10.17.1`, Rust dependencies maintained through `cargo`.

## Architecture
- React SPA located in `src/`, entry `main.tsx` binds to root node, `App.tsx` displays welcome interface and calls Rust commands.
- `src-tauri/src/lib.rs` exposes `greet` command, uses `tauri::Builder` to register plugins and commands then runs. `main.rs` only proxies to `uicontrol_lib::run()`.
- `tauri.conf.json` defines `beforeDevCommand`/`beforeBuildCommand`, controlling `pnpm` command calls during development and release phases, and declares window metadata and packaging targets.
- Static resource output directory is `dist`, integrated with Rust side through `frontendDist`.

## Command Design
- `pnpm dev`: Run Vite independently with hot reload, does not start Rust Runtime.
- `pnpm build`: Execute `tsc` type checking first, then execute `vite build` to generate production resources.
- `pnpm tauri`: Forward to Tauri CLI, commonly used subcommands `pnpm tauri dev`, `pnpm tauri build`.
- `cargo fmt --check`: Ensure Rust code style.
- `cargo clippy -- -D warnings`: Static analysis of Rust code.
- `cargo test`: Currently no tests but command can be used for regression detection, continue to use when supplementing unit tests later.

## File Specifications
- Frontend entry: `src/main.tsx`, root component `src/App.tsx`, styles concentrated in `src/App.css`.
- Resource management: Static resources like SVG stored in `src/assets/`, loaded through Vite resource pipeline.
- Rust configuration: `src-tauri/Cargo.toml` declares crate name and plugin dependencies, `src-tauri/src` stores actual implementation.
- Desktop configuration: `src-tauri/tauri.conf.json` responsible for window, packaging, DevServer hooks.
- TypeScript configuration: `tsconfig.json` + `tsconfig.node.json` + `vite.config.ts` manage aliases and compilation targets.

## Workflow
- Install dependencies: Execute `pnpm install` in `uicontrol/` directory, ensure stable Rust toolchain and `cargo` are installed locally.
- Development debugging: Recommend `pnpm tauri dev`, switch to `pnpm dev` for frontend-only iteration, Rust changes support `cargo watch` for self-configuration.
- Packaging and release: Use `pnpm tauri build`, output located in `src-tauri/target` subdirectory, three-platform installation packages generated by default.
- Quality verification: Frontend covers type checking through `pnpm build`, Rust uses `cargo fmt --check` and `cargo clippy -- -D warnings`, add `cargo test` when necessary.
- Version control: Before changes, confirm build artifacts like `dist/` and `node_modules/` are not tracked by Git, new Rust commands require synchronized updates to TypeScript calling layer.

## Extension Directions
- Replace `greet` with actual business commands, append `#[tauri::command]` in `src-tauri/src/lib.rs` and update `generate_handler`.
- Establish shared state or data layer (like Zustand/Redux) to manage complex UI, while ensuring type safety with Tauri command communication.
- Add end-to-end testing (Playwright) or Rust integration tests, supplement corresponding commands in this guide after completion.
- Evaluate introducing CI (e.g., GitHub Actions) to execute `pnpm build`, `cargo fmt --check`, `cargo clippy` to ensure submission quality.